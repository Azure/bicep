# Resource Scopes
> **Note:** Not implemented yet.

## Introduction / Motivation
A deployment in ARM has an associated scope, which dictates the scope that resources within that deployment are created in. There are various ways to deploy resources across multiple scopes today in ARM templates; this spec describes how similar functionality can be achieved in Bicep.

See [here][arm-scopes] for more information on ARM scopes.

## Declaring and using scopes

### Additional 'resourceId' Type
With the implementation of this feature, we introduce a new type `resourceId` (subtype of `string`). This type contains structured information about a resource identifier or scope, but with a string representation. We will allow `resourceId` to be assigned to a `string`, but not a `string` to be assigned to a `resourceId`.

### Resource 'id' Property
The existing readonly resource property `id` will be updated to return a `resourceId` type rather than a `string`. This will be a non-breaking change because we will allow assignment to `string` as discussed in [Additional 'resourceId' Type](#additional-resourceid-type).

### Resource 'scope' Property
An additional optional read-write property `scope` of type `resourceId` will be added to the `resource` type.

Assigning a scope to this field indicates that the resource must be deployed at that scope. If the field is not provided, the resource will be deployed at the default scope for the file (see [Implicit scope](#implicit-scope)).

```
resource myNic 'Microsoft.Network/networkInterfaces@2020-01-01 = {
  // use a different resource group scope for this resource
  scope: scope.resourceGroup(myExternalResourceGroup)
}
```

If the scope being assigned has been generated by another resource (for example the deployment of a resourceGroup), using this scope will set up an implicit dependency from child on parent.

### Global Functions
We will introduce an object named `scope` under the `az` namespaces, with the following methods, which will all return scopes of type `resourceId`:

```
scope.tenant() // returns the tenant scope
  
scope.managementGroup(name: string) // returns a named management scope

scope.subscription() // returns the subscription scope for the current deployment
scope.subscription(subscriptionId: string) // returns a named subscription scope

scope.resourceGroup() // returns the resource group scope for the current deployment
scope.resourceGroup(resourceGroupName: string) // returns a named resource group scope for a group in the same subscription
scope.resourceGroup(resourceGroupName: string, subscription: string)  // returns a named resource group scope

scope.extension(resourceId: string) // returns an extension scope for a given resourceId (external resource)
```

### Type checking
Internally, we will store the information about the type of the `resourceId` - this can be `TenantScope`, `ManagementGroupScope`, `SubscriptionScope`, `ResourceGroupScope` and `ExtensionScope`, allowing for combinations.

When type validation for resources has been implemented, we will use this information to verify that the scope type being passed to a resource matches an acceptable type or set of types for that resource.

## Implicit scope
For every `.bicep` file, we implicitly set the default scope to the deployment's resource group when generating ARM template output. Being able to modify this default scope for a file will be introduced in a separate spec.

## Example Usages
```
// deploy a resource group to the subscription scope
resource myRg 'Microsoft.Resources/resourceGroups@2020-01-01 = {
  name: 'myRg'
  location: 'West US'
  scope: scope.subscription()
}

// deploy a resource into the newly-created resource group
resource myNic 'Microsoft.Network/networkInterfaces@2020-01-01 = {
  name: 'myNic'
  location: 'West US'
  scope: myRg.id // use the scope of the newly-created resource group
}

// deploy an extension resource on the network interface
resource extension 'Microsoft.MockExtension/extension@2020-01-01 = {
  name: 'myExtension'
  scope: myNic.id // use the scope of the network interface to deploy the extension resource
}
```

## Allowed combinations of scopes
This feature will be limited to the same scoping constraints that exist within ARM Deployments today. We will prevent successful compilation of a template that cannot be deployed, with an error message explaining the constraint.

## Compatibility with upcoming features

### Defaults
With the introduction of defaults, we expect to be able to use this syntax to modify the implicit deployment scope of the `.bicep` file.

### Modules
Each module is expected to declare support for a scope or set of scopes using the same mechanism that is decided upon for [Defaults](#defaults). The syntax for assigning a scope to a module should be consistent with that of assigning it to a resource.

### Type Validation
See [Type checking](#type-checking)

[arm-scopes]: https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/overview#understand-scope

## Possible Extensions

### Parent-child syntax
We may want to use a similar concept to deploy child resources of a parent in a less-verbose manner - e.g.:
```
resource myParent 'My.Rp/parentType@2020-01-01' = {
  name: 'myParent'
  location: 'West US'
}

resource myChild 'My.Rp/parentType/childType@2020-01-01' = {
  parent: myParent.id // pass parent resourceId
  name: 'myChild' // don't require the full name to be formatted with '/' characters
}
```