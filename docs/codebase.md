# Codebase Overview
This document provides an overview of the Bicep compiler code structure, and design considerations.

## Project Structure
### Bicep.Core
### Bicep.Cli
### Bicep.LangServer
### VSCode Extension
### Peripherals (brief mention)
* Decompiler
* MSBuild
* Highlighter Libraries
* External packages (Deployments, Az Types)
### Pipelines & Build Process

## Compiler Structure
### Parser
The parser is responsible for converting a stream of text into an in-memory Bicep syntax tree. This is broken down into two stages: lexing and parsing. The lexer ([Lexer.cs](../src/Bicep.Core/Parsing/Lexer.cs)) is responsible from tokenizing a stream of text into distinct tokens. The parser ([Parser.cs](../src/Bicep.Core/Parsing/Parser.cs)) is responsible for taking the tokens generated by the lexer, and building a hierarchical syntax tree from them. Bicep uses a handwritten recursive-descent parsing mechanism to build its syntax trees.

Much of the complexity in the parser comes from the error recovery logic. See [Error Recovery](#error-recovery) for some more information on why this is important.

### Binder
The parser provides a syntax tree of a document, but is not able to understand the semantics of the document. The binder ([Binder.cs](../src/Bicep.Core/Semantics/Binder.cs)) provides the first step of being able to understand the semantics - being able to associate named identifiers (symbols) in the syntax trees with what they are referring to. To do this, it builds a symbol table; a dictionary to be able to efficiently find the symbol which a given piece of syntax is referring to.

### Semantic Analysis
* Type Checker
* Linters
* Emit-specific checks
### Emitter
* Emitter

### Compilation
The `Compilation` class ([Compilation.cs](../src/Bicep.Core/Semantics/Compilation.cs)) collects all of the necessary information about a Bicep file and related files in order to generate into an ARM template, obtain diagnostics, or answer semantic queries from the language server.

## Language Server Structure
* List handlers, brief mention how they integrate with compiler structure

## Type Generation
* Some mention of how this works

## Important Design Considerations
* Laziness & caching
### Error Recovery
When parsing a document or performing semantic analysis, it's very important to consider the fact that the document being parsed will very frequently be syntactically invalid. This is because the language server will generally request information after every single keypress. We always try and parse as much of the document as we can, and aim to recover from invalid/missing syntax as gracefully as possible, to avoid providing an inconsistent set of validations while the user is typing.

* Immutability
* Nullability
* Transparent abstraction (warnings rather than errors)

## Testing Considerations
* Easy baseline updates
* Preference for e2e instead of unit tests (both desirable)