# Using the symbolic resource name

Let's take another look at our storage account `resource`. As we discussed earlier, the resource declaration includes a **symbolic name**, which is separate from the name of the resource that will be created. The symbolic name is simply a reference to the resource within a Bicep project. It is a very useful pointer for retrieving properties of a resource and keeps your syntax readable and easy to manage.

## Retrieving the resource ID

Instead of using the `resourceId()` function, you can simply use the resource identifier and retrieve the relevant property. We've already done this with our output `stg.id`. In ARM Template JSON this will compile to `[resourceId('Microsoft.Storage/storageAccounts', parameters('name'))]`.

## Retrieving other "compile time" properties

Bicep special cases a few properties for which it will use the "compile-time" value. These include:

* `id`
* `name`
* `apiVersion`
* `type`

Let's add another `output` with the storage account name, which is useful to know since the name will be generated by the `uniqueString()` function when the template is deployed.

```bicep
param location string = resourceGroup().location
param namePrefix string = 'stg'

param globalRedundancy bool = true // defaults to true, but can be overridden

var storageAccountName = '${namePrefix}${uniqueString(resourceGroup().id)}'

resource stg 'Microsoft.Storage/storageAccounts@2019-06-01' = {
  name: storageAccountName
  location: location
  kind: 'Storage'
  sku: {
    name: globalRedundancy ? 'Standard_GRS' : 'Standard_LRS' // if true --> GRS, else --> LRS
  }
}

output storageId string = stg.id
output computedStorageName string = stg.name
```

You may find you need other properties like `apiVersion` for functions like [list*](https://docs.microsoft.com/azure/azure-resource-manager/templates/template-functions-resource#list).

## Retrieving "run-time" properties

In ARM Templates, I need to use the `reference()` function to retrieve run-time properties that only exist after the resource has been created. In a storage account, the `primaryEndpoints` property is one of those. With Bicep, I no longer need to use the `reference()` function and can instead use `.` property access to retrieve the same information.

Let's add another output to retrieve this run-time property:

```bicep
param location string = resourceGroup().location
param namePrefix string = 'stg'

param globalRedundancy bool = true // defaults to true, but can be overridden

var storageAccountName = '${namePrefix}${uniqueString(resourceGroup().id)}'

resource stg 'Microsoft.Storage/storageAccounts@2019-06-01' = {
  name: storageAccountName
  location: location
  kind: 'Storage'
  sku: {
    name: globalRedundancy ? 'Standard_GRS' : 'Standard_LRS' // if true --> GRS, else --> LRS
  }
}

output storageId string = stg.id
output computedStorageName string = stg.name
output blobEndpoint string = stg.properties.primaryEndpoints.blob // replacement for reference(...).*
```

## Automatically calculate dependsOn

In ARM Templates, you must manually specify resource dependencies with the `dependsOn` property. If we want to create a blob container in our storage account, we need to make sure the storage account gets created first.

With Bicep, if you reference any property of the prerequisite resource via the symbolic name, **we will automatically add the dependsOn property**.

Let's add a new resource for our blob container to our storage account, and reference the `name` property via symbolic name (`stg.name`):

```bicep
param location string = resourceGroup().location
param namePrefix string = 'stg'

param globalRedundancy bool = true // defaults to true, but can be overridden

var storageAccountName = '${namePrefix}${uniqueString(resourceGroup().id)}'

resource stg 'Microsoft.Storage/storageAccounts@2019-06-01' = {
  name: storageAccountName
  location: location
  kind: 'Storage'
  sku: {
    name: globalRedundancy ? 'Standard_GRS' : 'Standard_LRS' // if true --> GRS, else --> LRS
  }
}

resource blob 'Microsoft.Storage/storageAccounts/blobServices/containers@2019-06-01' = {
  name: '${stg.name}/default/logs'
  // dependsOn will be added when the template is compiled
}

output storageId string = stg.id // replacement for resourceId(...)
output computedStorageName string = stg.name
output primaryEndpoint string = stg.properties.primaryEndpoints.blob // replacement for reference(...).*
```

## Next steps

In the next tutorial, we will learn more advanced ways of declaring a resource with the `existing` keyword, conditionals, and loops.

[5 - Advanced resource declarations](./05-loops-conditions-existing.md)
