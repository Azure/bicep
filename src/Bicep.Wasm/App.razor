@using Bicep.Core.Syntax
@using Bicep.Core.SemanticModel
@using Bicep.Core.Emit
@using Bicep.Core.Text
<div class="container">
    <textarea class="left-half code" type="text" spellcheck="false" @bind="CurrentValue" @bind:event="oninput" />
    <div class="right-half code">@CompiledText</div>
</div>

@code {
    private static readonly string StartingTemplate = GetStartingTemplate();
    private static readonly string StartingTemplateCompiled = Compile(StartingTemplate);

    private string currentValue = StartingTemplate;

    private string CurrentValue
    {
        get => currentValue;
        set
        {
            CompiledText = Compile(value);
            currentValue = value;
        }
    }

    private string CompiledText { get; set; } = StartingTemplateCompiled;

    private static string GetStartingTemplate()
    {
        return ReadStreamToEnd(Assembly.GetExecutingAssembly().GetManifestResourceStream("Bicep.Wasm.basic.arm"));
    }

    private static string ReadStreamToEnd(Stream stream)
    {
        using var reader = new StreamReader(stream);
        return reader.ReadToEnd();
    }

    private static string Compile(string value)
    {
        try
        {
            var lineStarts = TextCoordinateConverter.GetLineStarts(value);
            var compilation = new Compilation(SyntaxFactory.CreateFromText(value));

            var emitter = new TemplateEmitter(compilation.GetSemanticModel());

            // memory stream is not ideal for frequent large allocations
            using var stream = new MemoryStream();
            var emitResult = emitter.Emit(stream);

            if (emitResult.Status != EmitStatus.Failed)
            {
                // compilation was successful or had warnings - return the compiled template
                stream.Position = 0;
                return ReadStreamToEnd(stream);
            }

            // compilation failed
            var buffer = new StringBuilder();
            foreach (var diagnostic in emitResult.Diagnostics)
            {
                var (line, character) = TextCoordinateConverter.GetPosition(lineStarts, diagnostic.Span.Position);

            // TODO: implement unique error codes in the Error class
                buffer.AppendLine($"({line + 1},{character + 1}): error {diagnostic.UserVisibleCode}: {diagnostic.Message}");
            }

            return buffer.ToString();
        }
        catch (Exception exception)
        {
            return exception.ToString();
        }
    }
}