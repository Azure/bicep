@using Bicep.Core.Syntax
@using Bicep.Core.SemanticModel
@using Bicep.Core.Emit
@using Bicep.Core.Text
@using Bicep.Core.Errors

@inject IJSRuntime JsRuntime;

<div class="container">
    <div id="editor_lhs" class="left-half" />
    <div id="editor_rhs" class="right-half" />
</div>

@code {
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        if (firstRender)
        {
            await JsRuntime.InvokeAsync<object>("CreateDemoEditors", DotNetObjectReference.Create(this));

            await JS_SetLhsContent(GetStartingTemplate());
            await JS_OnContentChanged();
        }
    }

    [JSInvokable]
    public async Task JS_OnContentChanged()
        => await Compile();

    public async Task<string> JS_GetLhsContent()
        => await JsRuntime.InvokeAsync<string>("GetLhsContent", new object[] { });

    public async Task JS_SetLhsContent(string value)
        => await JsRuntime.InvokeVoidAsync("SetLhsContent", new object[] { value });

    public async Task JS_SetRhsContent(string value)
        => await JsRuntime.InvokeVoidAsync("SetRhsContent", new object[] { value });

    public async Task JS_SetLhsDiagnostics(IEnumerable<dynamic> diagnostics)
        => await JsRuntime.InvokeVoidAsync("SetLhsDiagnostics", new object[] { diagnostics });

    private static dynamic ToMonacoDiagnostic(Error error, IReadOnlyList<int> lineStarts)
    {
        var (startLine, startChar) = TextCoordinateConverter.GetPosition(lineStarts, error.Span.Position);
        var (endLine, endChar) = TextCoordinateConverter.GetPosition(lineStarts, error.Span.Position + error.Span.Length);

        return new {
            code = error.UserVisibleCode,
            message = error.Message,
            startLineNumber = startLine + 1,
            startColumn = startChar + 1,
            endLineNumber = endLine + 1,
            endColumn = endChar + 1,
        };
    }

    private static string GetStartingTemplate()
    {
        return ReadStreamToEnd(Assembly.GetExecutingAssembly().GetManifestResourceStream("Bicep.WebDemo.basic.arm"));
    }

    private static string ReadStreamToEnd(Stream stream)
    {
        using var reader = new StreamReader(stream);
        return reader.ReadToEnd();
    }

    private async Task Compile()
    {
        try
        {
            var content = await JS_GetLhsContent();

            var lineStarts = TextCoordinateConverter.GetLineStarts(content);
            var compilation = new Compilation(SyntaxFactory.CreateFromText(content));

            var emitter = new TemplateEmitter(compilation.GetSemanticModel());

            // memory stream is not ideal for frequent large allocations
            using var stream = new MemoryStream();
            var emitResult = emitter.Emit(stream);

            await JS_SetLhsDiagnostics(emitResult.Diagnostics.Select(e => ToMonacoDiagnostic(e, lineStarts)));

            if (emitResult.Status != EmitStatus.Failed)
            {
                // compilation was successful or had warnings - return the compiled template
                stream.Position = 0;
                var template = ReadStreamToEnd(stream);
                await JS_SetRhsContent(template);

                return;
            }

            // compilation failed
            var buffer = new StringBuilder();
            foreach (var diagnostic in emitResult.Diagnostics)
            {
                var (line, character) = TextCoordinateConverter.GetPosition(lineStarts, diagnostic.Span.Position);

                buffer.AppendLine($"({line + 1},{character + 1}): error {diagnostic.UserVisibleCode}: {diagnostic.Message}");
            }

            await JS_SetRhsContent(buffer.ToString());
        }
        catch (Exception exception)
        {
            await JS_SetRhsContent(exception.ToString());
        }
    }
}